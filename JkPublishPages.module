<?php
    declare(strict_types=1);

    namespace ProcessWire;

    use Exception;


    /**
     *
     * JkPublishPages
     *
     * @author Jürgen K.
     * @copyright Copyright (c) 2023
     * @see http://www.processwire.com
     *
     * A module for publish/unpublish pages depending on date and time settings on per page base using Lazy Cron
     * In addition, you can decide what should happen with this page after publishing ends (move to trash, delete, set
     *     new parent) Uses LazyCron, which will be triggered on every page load
     */
    class JkPublishPages extends WireData implements Module, ConfigurableModule
    {

        protected array $moduleFields = [
            'jk_publish_open',
            'jk_publish_from',
            'jk_publish_until',
            'jk_action_after',
            'jk_move_child',
            'jk_publish_open_END'
        ];

        protected array $templates = []; // array of all templates which contain at least one of the module fields
        protected array $actions = []; // array that holds all possible actions after publishing has ended
        protected PageArray|null $parent_pages;

        protected int $publish_code = 0; // could the given page be published or not (-1,0,1) according to the date settings
        protected Page $page; // the current page, the inputfield lives on

        /**
         * Get all info about the module
         * @return array
         */
        public static function getModuleInfo(): array
        {
            return [
                'title' => 'Publish/Unpublish pages',
                'summary' => 'Publish and unpublish pages depending on dates and times using LazyCron.',
                'author' => 'Jürgen Kern',
                'href' => 'https://github.com/juergenweb/JkPublishPages',
                'version' => '1.3.9',
                'singular' => true,
                'autoload' => true,
                'requires' => [
                    'LazyCron',
                    'PHP>=8.0.0',
                    'ProcessWire>=3.0.195'
                ],
                'icon' => 'calendar-check-o'
            ];
        }

        public function __construct()
        {

            parent::__construct();

            // create the action array
            $this->actions = [
                '1' => $this->_('No action'),
                '2' => $this->_('Move page to trash'),
                '3' => $this->_('Move page as a child of another page'),
                '4' => $this->_('Delete page permanently')
            ];

        }

        /**
         * These are the default configuration values, which will be saved in the db during the installation process
         * @return array
         */
        public static function getDefaultData(): array
        {
            return [
                'input_croninterval' => 'everyHour',
                'input_default_action' => '1'
            ];
        }

        /**
         * Method to return a string out of the action array from the constructor
         * Method will be used for creating options during the creation of the jk_action_after select field
         * The string will be separated with new line breaks (\n)
         * @param array $array
         * @return string
         */
        protected function arrayToString(array $array): string
        {
            $string = '';
            foreach ($array as $key => $item) {
                $string .= $key . '=' . $item . "\n";
            }
            return $string;
        }

        /**
         * Get all templates which includes at least one of the module fields
         * Returns an array with the id of the template as the key and the name as value
         * @throws WireException
         */
        protected function getTemplatesWithModuleFields(): array
        {
            $templates = [];
            foreach ($this->wire('templates') as $t) {
                $result = $t->fields->find('name=jk_publish_open|jk_publish_from|jk_publish_until|jk_action_after|jk_move_child|jk_publish_open_END');
                if ($result->count) {
                    $templates[$t->id] = $t->name;
                }
            }
            return $templates;
        }

        /**
         * Get all pages, which includes at least one of the module fields as an array containing the ids of the pages
         * @return array
         * @throws WireException
         */
        protected function getPagesWithModuleFields(): array
        {
            $modulefield_pages = wire('pages')->find('templates_id=' . implode('|',
                    array_keys($this->getTemplatesWithModuleFields())) . ',include=all')->getArray();
            $page_ids = [];
            foreach ($modulefield_pages as $page) {
                $page_ids[] = $page->id;
            }
            return $page_ids;
        }

        /**
         * @return void
         * @throws WireException
         */
        public function init(): void
        {

            $this->page = $this->wire('pages')->get($this->input->get->id);

            $this->publish_code = $this->getPublishingCode($this->page->jk_publish_from, $this->page->jk_publish_until);


            // find all templates that include at least one of the publishing fields and save them to the input_templates array
            $data = $this->wire('modules')->getConfig($this);
            $data['input_templates'] = $this->getTemplatesWithModuleFields();
            wire('modules')->saveConfig($this, $data);

            //Add JS and CSS file
            $version = $this->getModuleInfo()['version'] . '-' . time();
            $this->config->scripts->add($this->config->urls->{$this->className()} . 'JkPublishPages.js?v=' . $version);
            $this->config->styles->add($this->config->urls->{$this->className()} . 'JkPublishPages.css?v=' . $version);

            // Hook for the Cron job
            $this->addHook("LazyCron::$this->input_croninterval", $this, 'runJkPublishPages');

            // Hooks for custom validation
            $this->addHookAfter('InputfieldDatetime::processInput', $this, 'validateDates');


            // Hook the change page list rendering
            $this->addHook("ProcessPageListRender::getPageLabel", $this, 'addPublishIcon');

            // Hook to add status text below the fieldset label
            $this->addHookAfter('InputfieldFieldsetOpen::render', $this, 'addStatusText');
            $this->addHookBefore('ProcessModule::executeEdit', $this, 'addRemovePublishingFields');
            $this->addHookAfter('ProcessLanguage::processCSV', $this, 'addTranslationsToFields');
            $this->addHookAfter('InputfieldPage::getSelectablePages', $this, 'setPageArrayNew');
            $this->addHookAfter('InputfieldCheckboxes::render', $this, 'addToggle');
            $this->addHookAfter('ProcessPageEdit::buildForm', $this, 'hideInputfield');
            $this->addHookAfter('Inputfield::render', $this, 'showParentPageName');


            // Hooks for preventing unwanted publishing/unpublishing of pages according to publishing settings
            $this->addHookBefore('ProcessPageList::ajaxAction', $this, 'changeStatusPageTree');
            $this->addHookBefore('Pages::publishReady', $this, 'preventSavingPublishStatus');
            $this->addHookBefore('Pages::unpublishReady', $this, 'preventSavingUnpublishStatus');
            $this->addHookBefore('Pages::saveReady', $this, 'changeStatus');

            // Hook to manipulate title in the admin
            $this->addHookAfter('ProcessPageEdit::execute', $this, 'extendTitleTag');


            $this->parent_pages = $this->getParentPages();
        }

        /**
         * Add the toggle link for the checkboxes to check/uncheck all checkboxes at once before the inputfield
         * The link will be displayed above the input field
         * @param HookEvent $event
         * @return void
         */
        protected function addToggle(HookEvent $event): void
        {
            $field = $event->object;
            if ($field->name == 'input_templates') {
                $return = $event->return;
                $toggle = '<div id="toggle-link" class="description">' . $this->_('Un/check all') . '</div>';
                $event->return = $toggle . $return;
            }
        }

        /**
         * Get a PageArray containing all pages that can be set as the new parent for the page that should be moved
         * @return PageArray|null
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function getParentPages(): PageArray|null
        {
            // get the current page object
            $current_page = $this->wire('pages')->get($this->wire('input')->get('id')); // the current page object

            if ($current_page->id > 0) {

                // create the selector to find allowed templates for parent pages
                $selectors = 'flags!="8",'; // exclude all system templates
                $selectors .= 'noChildren!=1,'; // exclude all templates which are not allowed to have children

                // include only templates which are allowed to be a parent template (if set in the current page template)
                if ($current_page->template->parentTemplates) {
                    $selectors .= 'id=' . implode('|', $current_page->template->parentTemplates);
                }

                // get all templates filtered by the selectors
                $templates = wire('templates')->find($selectors);

                // Exclude all templates which are not allowed to have the current page as child
                foreach ($templates as $key => $template) {
                    if (($template->childTemplates) && (!in_array($current_page->templates_id,
                            $template->childTemplates))) {
                        $templates->remove($key);
                    }
                }

                // create the array that consists of the ids of all allowed templates
                $templates = $templates->implode('|', 'id');
                // create the array that consists of the ids of all not allowed pages
                $exclude_pages = implode('|', [$current_page->id, $current_page->parent_id, 1]);
                return wire('pages')->find('id!=' . $exclude_pages . ',templates_id=' . $templates);
            } else {
                return null;
            }
        }

        /**
         * Create the new select options for the parent page depending on the allowed pages of each page
         * Not every template is allowed to be a parent of another template
         * So this method should filter out only the allowed templates for parent pages
         * The output will be a PageArray including all pages which use one of the given templates
         * @param HookEvent $event
         * @return void
         */
        protected function setPageArrayNew(HookEvent $event): void
        {
            $field = $event->object;
            if ($field->name == 'jk_move_child') {
                if (($this->parent_pages) && ($this->parent_pages->count)) {
                    $event->return = $this->parent_pages;
                }
            }
        }

        /**
         * Hide the parent page field on the edit form and remove the move option from the select field if there are no
         * pages that can be selected
         * @param HookEvent $event
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function hideInputfield(HookEvent $event): void
        {
            if (!$this->parent_pages->count) {
                $wrapper = $event->return;

                // remove the move to parent option from select field
                if ($wrapper->jk_action_after) {
                    $wrapper->jk_action_after->removeOption('3');
                }
                // hide the parent page field on the form
                if ($wrapper->jk_move_child) {
                    $wrapper->jk_move_child->collapsed = Inputfield::collapsedHidden;
                }
            }
        }

        /**
         * Add the parent page name next to the page name of the specified new parent page
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function showParentPageName(HookEvent $event): void
        {
            if (($this->input_show_parent) != null) {
                $field = $event->object;

                // run only on this field
                if ($field->name === 'jk_move_child') {

                    // original markup of this field
                    $return = $event->return;

                    // extract the id of the page of the id from the option value attribute
                    preg_match_all('/(<option[^>]+>)(.*?)(<\/option>)/i', $return, $result);

                    // create the new options including the parent page name inside the label
                    $options = [];
                    foreach ($result[0] as $item) {

                        // extract the label value of the option tag
                        preg_match('/<(\w+)[^>]*>(.*?)<\/\1>/', $item, $match);
                        $label = $match[2];
                        // grab the value of the option tag which contains the id
                        preg_match("/value='(.*?)'/", $item, $matches);
                        $id = (int)$matches[1];
                        // get the page object by its id
                        $page = $this->wire('pages')->get($id);
                        // get the parent page object of this page
                        $parent = $page->parent();
                        $parentName = $parent->name;

                        // replace the old label by the new one including the parent page name if parent name is not present
                        if (!str_contains($label, $parentName)) {
                            $options[] = str_replace($label, $label . '[' . $parentName . ']', $item);
                        } else {
                            $options[] = $item;
                        }

                    }

                    // add the new options between the old select tag
                    $options = implode($options);
                    $select = preg_replace('/(<select.*?>).*?(<\/select>)/', '$1' . $options . '$2', $return);

                    // Populate back the return value
                    $event->return = $select;

                }
            }
        }


        /**
         * Method to check if a button inside the page tree has been clicked
         * Stores the name of the action (fe "pub" for published) inside the session as the value
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         */
        protected function changeStatusPageTree(HookEvent $event): void
        {
            $action = $event->arguments(0);
            $this->wire('session')->set('action', $action);
        }

        /**
         * Prevent the change of unpublishing to publish of a page if the conditions to publish the page are not
         * fullfilled. If the page could not be published, a modal window including more information will be displayed.
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function preventSavingPublishStatus(): void
        {

            $error_msg = [];

            $not_allowed_text = $this->_('The publishing settings of this page do not allow you to manually publish this page now.');
            $end_text = $this->_('Otherwise, the page cannot be published immediately.');
            $status_remains_text = $this->_('The status of this page remains "unpublished" at the moment.');

            if (($this->wire('session')->get('action') == 'pub') && ($this->publish_code < 0)) {
                $error_msg[] = $not_allowed_text;
                $error_msg[] = $this->_('To publish the page, go to the edit page, make your changes to the date fields and then publish the page.');
                $error_msg[] = $end_text;
                $error_msg[] = $status_remains_text;
                $error_msg = implode(' ', $error_msg);
                $this->wire('session')->remove('action');
                throw new WireException($error_msg);

            }
        }

        /**
         * Prevent the change of publishing to unpublish if the conditions to unpublish the page are not
         * fullfilled. If the page could not be unpublished, a modal window including more information will be
         * displayed.
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function preventSavingUnpublishStatus(): void
        {

            $error_msg = [];

            $not_allowed_text = $this->_('The publishing settings of this page do not allow you to manually unpublish this page now.');
            $end_text = $this->_('Otherwise, the page cannot be unpublished immediately.');
            $status_remains_text = $this->_('The status of this page remains "published" at the moment.');

            if (($this->wire('session')->get('action') == 'unpub') && ($this->publish_code > 0)) {
                $error_msg[] = $not_allowed_text;
                $error_msg[] = $this->_('To unpublish the page, go to the edit page, make your changes to the date fields and the status field, and then unpublish the page.');
                $error_msg[] = $end_text;
                $error_msg[] = $status_remains_text;
                $error_msg = implode(' ', $error_msg);
                $this->wire('session')->remove('action');
                throw new WireException($error_msg);
            }

        }

        /**
         * Manipulate the headline and add a sub-headline
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function extendTitleTag(HookEvent $event): void
        {

            // Get page being edited
            $page = $event->object->getPage();

            // Only use on pages with publishing fields
            if (!$page->hasField('jk_publish_from')) return;

            // modify the existing headline
            $headline = $this->wire('processHeadline');

            $action = $this->getScheduleAction($page, true);

            $icon = '';
            $subHeadline = '';
            if (!empty($action)) {
                $icon = ' (*)';
                $subHeadline = '<p class="notes" style="padding: 5px; font-size: 20px;"><i class="fa fa-exclamation-triangle"></i>&nbsp;<sup>*</sup>' . ucfirst($action) . '</p>';
            }
            $this->wire('processHeadline', $headline . $icon);

            $return = $event->return;

            $event->return = $subHeadline . $return;

        }

        /**
         * Helper function to convert a date to a timestamp or return null if nothing is entered
         * @param int|string|null $datevalue
         * @param string|null $dateformat
         * @return int|null
         * @throws \ProcessWire\WireException
         */
        protected function convertDateValue(int|string|null $datevalue, string|null $dateformat = null): int|null
        {

            if (!empty($datevalue) && ($datevalue != '')) {
                if (is_string($datevalue)) {
                    if ($this->wire('sanitizer')->date($datevalue, $dateformat)) {
                        return $this->wire('datetime')->stringToTimestamp($datevalue, $dateformat);
                    }
                    return null;
                }
                return $datevalue;
            }
            return null;
        }

        /**
         * Check if a given date is in time range between 1 date or 2 dates or not
         * Returns true if it is in time range or false if not
         * @param int|string|null $startdate
         * @param int|string|null $enddate
         * @param int|null $date_to_check
         * @return int
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function getPublishingCode(int|string|null $startdate, int|string|null $enddate, int|null $date_to_check = null): int
        {

            // Publishing codes
            // 0 ... published/unpublished
            // -1 ...only unpublished
            // 1 …only published

            $startdate_field = $this->wire('fields')->get('jk_publish_from');
            $startdate_format = implode(' ', [$startdate_field->dateInputFormat, $startdate_field->timeInputFormat]);
            $untildate_field = $this->wire('fields')->get('jk_publish_until');
            $untildate_format = implode(' ', [$untildate_field->dateInputFormat, $untildate_field->timeInputFormat]);

            // if no date to check is entered, then the current date/time will be used instead
            $check_ts = (is_null($date_to_check)) ? time() : $date_to_check;

            $start_ts = $startdate;
            if (is_string($startdate)) {
                $start_ts = $this->wire('datetime')->stringToTimestamp($startdate, $startdate_format);
            }

            $end_ts = $enddate;
            if (is_string($enddate)) {
                $end_ts = $this->wire('datetime')->stringToTimestamp($enddate, $untildate_format);
            }

            // no entries -> page can be published or unpublished
            if (empty($start_ts) && empty($end_ts)) {
                return 0;
            }

            // no start, but end date
            if (empty($start_ts)) {
                if ($end_ts >= $check_ts) {
                    // end date is in the future -> can be published or unpublished
                    return 0;
                } else {
                    // end date is in the past -> only unpublished
                    return -1;
                }
            } else {

                if (empty($end_ts)) {

                    if ($start_ts > $check_ts) {
                        // start date is in the future -> page must be unpublished
                        return -1;
                    } else {
                        // start date is in the past or in the present -> page must be published
                        return 1;
                    }
                } else {

                    // check if the date is between start & end
                    if (($check_ts >= $start_ts) && ($check_ts <= $end_ts)) {
                        // date is in time range -> must be published
                        return 1;
                    } else {
                        // date is not in time range -> must be unpublished
                        return -1;
                    }
                }

            }
        }

        /**
         * Method to add a new status code to the WireInputData object
         * @param \ProcessWire\WireInputData $input
         * @param int $status
         * @return \ProcessWire\WireInputData
         */
        protected function addInputStatus(WireInputData $input, int $status): WireInputData
        {
            if (isset($input->status)) {
                $status_array = $input->status;
                array_unshift($status_array, $status);
                $input->set('status', $status_array);
            } else {
                $input->set('status', [$status]);
            }
            return $input;
        }

        /**
         * Method to remove a specific status code from the WireInputData object
         * @param \ProcessWire\WireInputData $input
         * @param int $status
         * @return \ProcessWire\WireInputData
         */
        protected function removeInputStatus(WireInputData $input, int $status): WireInputData
        {
            if (isset($input->status)) {
                if (($key = array_search($status, $input->status)) !== false) {
                    $status_array = $input->status;
                    unset($status_array[$key]);
                    $input->set('status', $status_array);
                }
            }
            return $input;
        }

        /**
         * Change the status of the page according to the publishing settings
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function changeStatus(HookEvent $event): void
        {

            $page = $event->arguments(0);

            if ($this->wire('session')->get('changestatus')) {

                $status = $this->wire('session')->get('changestatus');

                if ($status === 'unpub') {
                    $page->setStatus('unpublished');
                } else {
                    $page->removeStatus('unpublished');
                }
                $this->wire('session')->remove('changestatus');
                $event->arguments(0, $page);
            }

        }

        /**
         * Method to validate if publish_until is after publish_from, otherwise show an error at the publish_until field
         * @param HookEvent $event
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function validateDates(HookEvent $event): void
        {
            $f = $event->object;

            if ($f->name == 'jk_publish_from' || $f->name == 'jk_publish_until') {

                $input = $this->wire('input');
                $datetime = $this->wire('datetime');

                // convert start and end date in specific format to timestamp
                $startdate_field = $this->wire('fields')->get('jk_publish_from');
                $start_date_format = $startdate_field->dateInputFormat;
                $start_time_format = $startdate_field->timeInputFormat;
                $start_format = implode(' ', [$start_date_format, $start_time_format]);
                $start_ts = $datetime->stringToTimestamp($input->jk_publish_from, $start_format);

                $enddate_field = $this->wire('fields')->get('jk_publish_until');
                $end_date_format = $enddate_field->dateInputFormat;
                $end_time_format = $enddate_field->timeInputFormat;
                $end_format = implode(' ', [$end_date_format, $end_time_format]);
                $end_ts = $datetime->stringToTimestamp($input->jk_publish_until, $end_format);

                // set default values
                $comparison = false;
                $validation = true; // set default validation result to true - everything is ok;
                $pub_code = $this->getPublishingCode($start_ts, $end_ts);

                // text phrases for the error messages
                $future_text = mb_strtoupper($this->_('future'));
                $past_text = mb_strtoupper($this->_('past'));
                $empty_text = mb_strtoupper($this->_('empty'));
                $published_text = $this->_('published');
                $unpublished_text = $this->_('unpublished');
                $save_page_with_status = $this->_('To be able to save this page with status "%s" immediately, this field must have a value in the "%s" or it must remain "%s".');
                $old_date_text = $this->_('The date you have entered was "%s" (%s).');

                // determine which status should be saved for this page (true = published, false = unpublished)
                if (isset($input->submit_publish)) {
                    $action_publish = true;
                } else {
                    $action_publish = (isset($input->status) && (in_array('2048', $input->status))) ? false : true; // overwrite value depending on if status code 2048 is present
                }

                // check if wanted action is the same as the allowed action
                $status_change = false;
                $wanted_action = ($action_publish) ? 1 : -1;

                if ($pub_code != 0) {
                    $status_change = ($pub_code != $wanted_action);
                }

                $msg = []; // create the array that holds the error messages

                if ($f->name == 'jk_publish_from') {

                    /********************/
                    /**** START DATE ****/
                    /********************/

                    // check if the date entered is in the past or in the future
                    $tense = ($start_ts <= time()) ? $past_text : $future_text;

                    if (!empty($start_ts)) {
                        // run only if the start date field contains a value
                        if ($action_publish) {
                            // page should be published
                            if ($start_ts > time()) {
                                // value is in the future -> error
                                $validation = false;
                                $msg[] = sprintf($save_page_with_status, $published_text, $past_text, $empty_text);
                            }
                        } else {
                            // page should be unpublished
                            if ($start_ts <= time()) {
                                if (!is_null($end_ts)) {

                                    if ($end_ts <= time()) {
                                        // should be unpublished
                                        $validation = true;
                                        //should be published
                                        if ($wanted_action == 1)
                                            $validation = false;
                                    } else {
                                        if ($wanted_action == -1)
                                            $validation = false;
                                    }
                                } else {
                                    $validation = false;
                                }

                                // value is in the past or in the present -> error
                                if (!$validation)
                                    $msg[] = sprintf($save_page_with_status, $unpublished_text, $future_text, $empty_text);

                            }
                        }

                        // check if start value is after end value
                        if (!is_null($end_ts)) {
                            $comparison = ($start_ts > $end_ts);
                        }

                    }

                } else {

                    /******************/
                    /**** END DATE ****/
                    /******************/

                    // check if the date entered is in the past or in the future
                    $tense = ($end_ts <= time()) ? $past_text : $future_text;

                    if (!empty($end_ts)) {
                        // run only if the start date field contains a value
                        if ($action_publish) {
                            // page should be published
                            if ($end_ts <= time()) {

                                // value is in the past or in the present -> error
                                $validation = false;
                                $msg[] = sprintf($save_page_with_status, $published_text, $future_text, $empty_text);

                            }
                        }
                    }

                }

                $field_name = $f->name;

                if ($comparison) {

                    $msg[] = $this->_('The value of the the start publishing field must be before the value of the end of publishing field.');
                    $msg[] = sprintf($this->_('You have entered "%s", which is after the end date "%s".'), $input->jk_publish_from, $input->jk_publish_until);

                } else if (!$validation) {
                    
                    $msg[] = sprintf($old_date_text, $input->$field_name, $tense);
                }

                // set status to publish or unpublish
                if ($pub_code < 0) {
                    $status = 'unpub';
                } else if ($pub_code > 0) {
                    $status = 'pub';
                } else {
                    $status = ($wanted_action == 1) ? 'pub' : 'unpub';
                }

                $this->wire('session')->set('changestatus', $status);

                // output error message if present
                if ($msg) {
                    $f->error(implode(' ', $msg));
                }

                // run only once
                if ($f->name == 'jk_publish_until') {

                    if ($status_change) {
                        $status_action = ($action_publish) ? $published_text : $unpublished_text;
                        $saved_status = ($status == 'pub') ? $published_text : $unpublished_text;
                        $this->warning(sprintf($this->_('Please note: You have tried to save this page with status "%s", but according to your publish settings, this page could only be saved with status "%s"'), $status_action, $saved_status));
                    }

                }

            }
        }

        /**
         * Add an icon to all pages in the page tree, which will be published or unpublished in the future
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function addPublishIcon(HookEvent $event): void
        {
            // get current list page with pagetree
            $return = $event->return;
            $page = $event->arguments(0);

            $action = $this->getScheduleAction($page, true);

            if (!empty($action)) {

                $icon = '<i class="fa fa-clock-o" title="' . ucfirst($action) . '"></i>';
                $return = str_replace("<span class='label_title'>", "<span class='label_title'>" . $icon, $return);
            }

            $event->return = $return;
        }

        /**
         * Helper function to check if the array contains specific keys by name
         * @param array $data
         * @param array $keynames
         * @return bool
         */
        protected function checkForArrayKeysByName(array $data, array $keynames): bool
        {
            if (count(array_intersect_key(array_flip($keynames), $data)) === count($keynames)) {
                return true;
            }
            return false;
        }

        /**
         * Output texts for upcoming publishing actions
         * Checks if the start and end date are set, if the page is currently published or not,
         *  if the start and/or end date is in the past or in the future.
         * Very complex code to ouput a text, that informs the user what will happen in the future
         * according to the given settings.
         * @param \ProcessWire\Page $page
         * @param bool $removeNoChange
         * @return string|null
         * @throws \ProcessWire\WireException *
         * @throws \ProcessWire\WirePermissionException
         */
        protected function getScheduleAction(Page $page, bool $removeNoChange = false): string|null
        {

            if ($page->hasField('jk_publish_from')) {

                $dateformat = $this->wire('fields')->get('jk_publish_from')->dateOutputFormat;
                $start_date = $page->getUnformatted(('jk_publish_from'));
                $start_date_formatted = $this->wire('datetime')->date($dateformat, $start_date);
                $end_date = $page->getUnformatted(('jk_publish_until'));
                $end_date_formatted = $this->wire('datetime')->date($dateformat, $end_date);
                $current_time = time();
                $text_blocks = [];

                // texts
                $publish_text = $this->_('published');
                $unpublish_text = $this->_('unpublished');
                $nochange_text = $this->_('remains "%s"');
                $date_text = $this->_('will be "%s" on %s');

                // STARTDATE VALUES
                if ((int)$start_date) {

                    if ($start_date >= $current_time) { // start date is in the future
                        // the page is unpublished
                        if ($page->is(Page::statusUnpublished)) {
                            // will be published on.....
                            $text_blocks['spd'] = sprintf($date_text, $publish_text, $start_date_formatted);
                        }
                    }
                }

                // ENDATE VALUES
                if ((int)$end_date) {

                    if ($end_date >= $current_time) {
                        //END DATE IN THE FUTURE
                        // will be unpublished on.....
                        if ((int)$start_date) {
                            $text_blocks['eud'] = sprintf($date_text, $unpublish_text, $end_date_formatted);
                        } else {
                            if (!$page->is(Page::statusUnpublished)) {
                                //the page is unpublished and no automatic publishing
                                $text_blocks['eud'] = sprintf($date_text, $unpublish_text, $end_date_formatted);
                            }
                        }

                    }
                }

                // Special case for start date in the future and end date in the past
                // This case needs a special treatment for the output
                if (($start_date && $end_date) && ($start_date > $end_date)) {
                    $text_blocks = [];
                    if ($page->is(Page::statusUnpublished)) {
                        // clear the array first
                        $text_blocks['nochange'] = sprintf($nochange_text, $unpublish_text);
                    } else {
                        $text_blocks['nochange'] = sprintf($nochange_text, $publish_text);
                    }
                }

                // remove all other array items and warnings if "nochange" key is present
                if (array_key_exists('nochange', $text_blocks)) {
                    $value = $text_blocks['nochange'];
                    $text_blocks = [];
                    $text_blocks['nochange'] = $value;

                }

                if (!$text_blocks) {
                    // show "remains published or unpublished" text
                    $text = ($page->is(Page::statusUnpublished)) ? $unpublish_text : $publish_text;
                    $text_blocks = [];// clear the array first
                    $text_blocks['nochange'] = sprintf($nochange_text, $text);
                }

                // remove all array items with key nochange if set in the function parameter
                if ($removeNoChange) {
                    unset($text_blocks['nochange']);
                }

                if (count($text_blocks)) {
                    return implode(', ', $text_blocks);
                } else {
                    return null;
                }

            }
            return null;
        }

        /**
         * Adds a text below the label of the fieldset to inform the user about future activities
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function addStatusText(HookEvent $event): void
        {
            $InputfieldFieldset = $event->object;
            $page = $InputfieldFieldset->hasPage;

            // An 'after' hook can retrieve and/or modify the return value
            $return = $event->return;

            // get the JkpublishPages fieldset
            if ($InputfieldFieldset->name === 'jk_publish_open') {

                // create the status texts
                if ($page->is('unpublished')) {
                    $status_text = $this->_('unpublished');
                } else if (!$page->is('unpublished')) {
                    $status_text = $this->_('published');
                } else {
                    $status_text = '';
                }

                if ($status_text != '') {
                    $text = sprintf($this->_('Page is currently %s.'), '<b>' . $status_text . '</b>') . '<br>';
                } else {
                    $text = '';
                }

                $action = $this->getScheduleAction($page);

                $text .= '<br><u>' . $this->_('Schedule plan:') . '</u>';

                // convert the comma separated list to an unordered list for better readability
                if (!is_null($action)) {
                    $items = explode(',', $action);
                    if (count($items)) {
                        $action = '<ul>';
                        foreach ($items as $item) {
                            $action .= '<li>' . $item . '</li>';
                        }
                        $action .= '</ul>';
                    }

                    $text .= $action;

                } else {
                    $text .= '<ul><li>' . $this->_('The status of the publication will remain unchanged in the future.') . '</li></ul>';
                }
                $a = "<ul class='Inputfields";
                $b = "<div id='scheduleplan'>" . $text . "</div><br><ul class='Inputfields";
                $return = str_replace($a, $b, $return);

            }

            $event->return = $return;
        }

        /**
         *
         * Publish or unpublish pages including publishing fields depending on page settings
         * Search for pages with status published or unpublished, no pages in trash, no pages under the admin, template
         * has publishing fields inside and the date and time settings are out of time - so status should be changed
         * @return void
         * @throws WireException
         */
        protected function runJkPublishPages(): void
        {

            // find all templates which have a start date field
            $templates = [];
            foreach ($this->wire('templates') as $template) {
                if ($template->hasField('jk_publish_from')) {
                    $templates[] = $template->id;
                }
            }

            $templateSelector = ($templates) ? 'template=' . implode('|', $templates) . ',' : '';

            // create general selector for unpublished and published pages
            $selectors = 'id=' . implode('|',
                    $this->getPagesWithModuleFields()) . ',';// exclude all pages, which do not have module fields inside

            $selectors .= 'has_parent!=' . wire("config")->adminRootPageID . ','; // exclude all pages under the admin control panel
            $selectors .= 'has_parent!=' . wire("config")->trashPageID . ','; // exclude all pages in trash

            /* Publish conditions */
            // 1) jk_publish_from<=now, jk_publish_until=>now
            // 2) jk_publish_from<=now, jk_publish_until=

            /* Unpublish conditions */
            // 1) jk_publish_from>=now, jk_publish_until>=now
            // 3) jk_publish_from>=now, jk_publish_until=
            // 2) jk_publish_from<=now, jk_publish_until<=now
            // 4) jk_publish_from=, jk_publish_until<=now

            $pagesToUnpublish = wire("pages")->find($selectors . "status=published,$templateSelector(jk_publish_from>=now, jk_publish_until>=now),(jk_publish_from>=now, jk_publish_until=),(jk_publish_from<=now, jk_publish_until<=now),(jk_publish_from=, jk_publish_until<=now)");
            $pagesToPublish = wire("pages")->find($selectors . "status=unpublished,$templateSelector(jk_publish_from<=now, jk_publish_until>=now),(jk_publish_from<=now, jk_publish_until=)");

            $results = $pagesToUnpublish->import($pagesToPublish);

            foreach ($results as $p) {
                $p->setOutputFormatting(false);
                if ($p->isUnpublished()) {
                    $p->removeStatus(Page::statusUnpublished);
                } else {
                    switch ($p->jk_action_after->id) {
                        case('2'): // move to trash
                            $p->trash();
                            break;
                        case('3'): // move page under a new parent
                            $p->jk_publish_until = '';
                            $p->jk_action_after = '1';
                            $p->parent = $p->jk_move_child->first();
                            break;
                        case('4'): // delete permanently
                            $p->delete();
                            break;
                        default: // set page status to unpublished
                            $p->addStatus(Page::statusUnpublished);
                    }
                }
                $p->save();
            }

        }

        /**
         * Remove module fields from each template inside the templates' array
         * @param array $templates
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function removeFields(array $templates): void
        {
            foreach ($templates as $template) {
                $currentTempl = wire('templates')->get($template);
                foreach ($this->moduleFields as $fieldName) {
                    $currentTempl->fieldgroup->remove($fieldName);
                }
                $currentTempl->fieldgroup->save();
            }

        }

        /**
         * Add module fields to each template inside the templates' array
         * @param array $templates
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function addFields(array $templates): void
        {
            foreach ($templates as $template) {
                $currentTempl = wire('templates')->get($template);

                if ($currentTempl) {
                    foreach ($this->moduleFields as $fieldName) {
                        $field = wire('fields')->get($fieldName);

                        if (!$currentTempl->hasField($fieldName)) {
                            $currentTempl->fieldgroup->add($field);
                        }
                    }
                    $currentTempl->fieldgroup->save();
                }
            }
        }

        /**
         * Add or remove publishing fields from templates after saving the module config page
         * If a template is not checked in the module config, then all publishing fields will be removed from it,
         * otherwise they will be added to the template
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function addRemovePublishingFields(): void
        {
            $all_templates = [];
            foreach ($this->wire('templates') as $template) {
                $all_templates[$template->id] = $template->name;
            }
            if ($this->input_templates) {
                $delete_templates = array_diff($all_templates, $this->input_templates);
                $this->addFields($this->input_templates);
                $this->removeFields($delete_templates);
            }
        }

        /**
         * Method to add translation to the labels of fields created by this module
         * Only works if ProcessWire version is equal or higher 3.0.195
         * After uploading the csv translation file, the translations will be also stored at the created fields
         * @param HookEvent $event
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         * @noinspection DuplicatedCode
         */
        protected function addTranslationsToFields(HookEvent $event): void
        {
            // get the language object of the uploaded translation csv file
            $language = $event->arguments(1);

            $translation = new LanguageTranslator($language);

            foreach ($this->moduleFields as $fieldName) {
                //grab the field object
                $f = $this->wire('fields')->get($fieldName);
                // create array if field properties that should be set and saved
                $field_properties = ['label', 'description', 'notes'];
                foreach ($field_properties as $property) {
                    if ($f->$property) {
                        ${$property} = $translation->getTranslation($this, $f->$property);
                        $property_lang = $property . $language->id;
                        $f->set($property_lang, ${$property});
                        $f->save($property);
                    }
                }
                // only for multi-language site -> save the select options in the given language from the csv file
                if (($this->wire('languages')) && ($fieldName == 'jk_action_after')) {

                    //get the text-domain
                    $textdomain = $translation->objectToTextdomain($this);

                    foreach ($this->actions as $action) {

                        $title = $this->wire('sanitizer')->string($translation->getTranslation($textdomain, $action));

                        $table_name = 'fieldtype_options';

                        // check if language is the default language
                        $id = '';
                        if ($language->id != $this->wire('languages')->getDefault()->id) {
                            $id = $language->id;
                        }

                        $values = 'title' . $id . ' = "' . $title . '"';
                        $where = 'fields_id="' . $f->id . '" AND title="' . $action . '"';
                        $query = 'UPDATE ' . $table_name . ' SET ' . $values . ' WHERE ' . $where;
                        try {
                            $insert = $this->wire('database')->prepare($query);
                            $this->wire('database')->execute($insert);
                        } catch (Exception $e) {
                            $this->trackException($e, false, true);
                        }
                    }
                }
            }
        }

        /**
         * Get all frontend templates as a numeric array with template name as value
         * Home template is excluded!
         * @return array
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function getTemplates(): array
        {
            $templates = [];
            //grab template of home page
            $homepage = wire('pages')->get(1);
            //exclude templates
            $exclude = [
                $homepage->template->name,
                // exclude templates from FrontendLogin module
                // this only for future purposes - do not wonder
                'fl_activationpage',
                'fl_deleteaccountpage',
                'fl_deleterequestpage',
                'fl_forgotlogindatapage',
                'fl_loginpage',
                'fl_logoutpage',
                'fl_profilepage',
                'fl_recoverylogindatapage',
                'fl_registerpage'
            ];
            $query_string = 'flags!="8",name!=' . implode('|', $exclude);

            foreach (wire('templates')->find($query_string) as $template) {
                $templates[] = $template->name;
            }
            return $templates;
        }

        /**
         * Return all cron intervals with translatable labels
         * @return array
         */
        public function getCronIntervals(): array
        {
            return [
                'every30Seconds' => $this->_('Every 30 seconds'),
                'everyMinute' => $this->_('Every minute'),
                'every2Minutes' => sprintf($this->_('Every %s minutes'), '2'),
                'every3Minutes' => sprintf($this->_('Every %s minutes'), '3'),
                'every4Minutes' => sprintf($this->_('Every %s minutes'), '4'),
                'every5Minutes' => sprintf($this->_('Every %s minutes'), '5'),
                'every10Minutes' => sprintf($this->_('Every %s minutes'), '10'),
                'every15Minutes' => sprintf($this->_('Every %s minutes'), '15'),
                'every30Minutes' => sprintf($this->_('Every %s minutes'), '30'),
                'every45Minutes' => sprintf($this->_('Every %s minutes'), '45'),
                'everyHour' => $this->_('Every hour'),
                'every2Hours' => sprintf($this->_('Every %s hours'), '2'),
                'every4Hours' => sprintf($this->_('Every %s hours'), '4'),
                'every6Hours' => sprintf($this->_('Every %s hours'), '6'),
                'every12Hours' => sprintf($this->_('Every %s hours'), '12'),
                'everyDay' => $this->_('Every day'),
                'every2Days' => sprintf($this->_('Every %s days'), '2'),
                'every4Days' => sprintf($this->_('Every %s days'), '4'),
                'everyWeek' => $this->_('Every week'),
                'every2Weeks' => sprintf($this->_('Every %s weeks'), '2'),
                'every4Weeks' => sprintf($this->_('Every %s weeks'), '4')
            ];

        }

        /**
         * Config input fields
         * @param $inputfields
         * @return void
         * @throws WirePermissionException|WireException
         */
        public function ___getModuleConfigInputfields($inputfields): void
        {
            // create the array of CronJob intervals
            $intervals = $this->getCronIntervals();

            /* @var InputfieldSelect $f */
            $f = $this->modules->get('InputfieldSelect');
            $f->label = $this->_('Cron Interval');
            $f->description = $this->_('Please select the interval at which a page should be checked for publication options.');
            $f->attr('name', 'input_croninterval');
            $f->addOptions($intervals);
            $f->value = $this->input_croninterval;
            $f->required = 1;
            $inputfields->append($f);

            /* @var InputfieldCheckboxes $f */
            $f = $this->modules->get('InputfieldCheckboxes');
            $f->label = $this->_('Add fields to templates');
            $f->attr('name', 'input_templates');

            foreach ($this->getTemplates() as $templateName) {
                $checked = ($this->input_templates != null && in_array($templateName,
                        $this->input_templates)) ? 'checked' : '';
                $f->addOption($templateName, $templateName, ['checked' => $checked]);
            }
            $f->description = $this->_('If a template is checked, than the publishing fields are present in this template or will be added to this template after pressing the save button. On all other templates these fields are not present or will be removed after pressing the save button.');
            $f->notes = $this->_('Please select all templates where you want to add the publishing fields and press the save button afterwards. Only to mention: The homepage template is excluded!');
            $inputfields->append($f);

            /* @var InputfieldCheckbox $f */
            $f = $this->modules->get('InputfieldCheckbox');
            $f->label = $this->_('Show parent page name beside the page name');
            $f->attr('name', 'input_show_parent');
            $checked = ($this->input_show_parent != null) ? 'checked' : '';
            $f->attr('checked', $checked);
            $f->description = $this->_('If you check the box, then the parent page name will be displayed beside the page name which will be set as new parent after publishing time has been expired.');
            $f->notes = $this->_('This could be useful, especially if you are running a multi-domain-site containing pages with same page name. Adding the parent page name will give you the possibility to distinguish pages with same page name.');
            $inputfields->append($f);

        }

        /**
         * Run during installation of this module
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        public function ___install(): void
        {
            // grab the default config data of the module and save it to the database
            $data = self::getDefaultData();
            wire('modules')->saveConfig($this, $data);

            // Create the required fields for this module and save them to the database
            if (!wire('fields')->get('jk_publish_from')) {
                $f = new Field();
                $f->type = $this->modules->get('FieldtypeDatetime');
                $f->name = 'jk_publish_from';
                $f->label = $this->_('Publish From Date');
                $f->dateOutputFormat = 'd-M-Y H:i:s';
                $f->dateInputFormat = 'd/m/Y';
                $f->datepicker = 3; // if you want datepicker enabled
                $f->timeInputFormat = 'H:i';
                $f->yearRange = '+0:+10';
                $f->defaultToday = 0; // if you want dates to default to today
                $f->columnWidth = 50;
                $f->save();
            }

            if (!wire('fields')->get('jk_publish_until')) {
                $f = new Field();
                $f->type = $this->modules->get('FieldtypeDatetime');
                $f->name = 'jk_publish_until';
                $f->label = $this->_('Publish Until Date');
                $f->dateOutputFormat = 'd-m-Y H:i:s';
                $f->dateInputFormat = 'd/m/Y';
                $f->datepicker = 3; // if you want datepicker enabled
                $f->timeInputFormat = 'H:i';
                $f->yearRange = '+0:+10';
                $f->defaultToday = 0; // if you want dates to default to today
                $f->columnWidth = 50;
                $f->save();
            }

            // create select field for action after publishing time has ended
            if (!wire('fields')->get('jk_action_after')) {

                $f = new Field();
                $f->type = $this->modules->get('FieldtypeOptions');
                $f->name = 'jk_action_after';
                $f->label = $this->_('Action after publication has ended');
                $f->inputfield = 'InputfieldChosenSelect';

                $f->showIf = 'jk_publish_until!=""';
                $f->required = true;
                $f->requiredIf = 'jk_publish_until!=""';
                $f->defaultValue = 1;
                $f->description = $this->_('Decide what should happen with this page after the publish end date has been reached.');
                $f->save();

                // adding options
                $set_options = new SelectableOptionManager();
                $options = $this->arrayToString($this->actions);
                $set_options->setOptionsString($f, $options, false);
                $f->save();

            }

            // create select field for action after publishing time has ended
            if (!wire('fields')->get('jk_show_parent')) {
                $f = new Field();
                $f->type = $this->modules->get('FieldtypePage');
                $f->name = 'jk_move_child';
                $f->label = $this->_('Parent page');
                $f->description = $this->_('Select the page which should be the new parent page for this page.');
                $f->notes = $this->_('The homepage is not allowed to be the new parent, so it will not be displayed inside the select drop-down.');
                $f->showIf = 'jk_action_after=3';
                $f->defaultValue = '1';  // set homepage as default value
                $f->required = true;
                $f->requiredIf = 'jk_action_after=3';
                $f->inputfield = 'InputfieldSelect';
                $f->save();
            }

            // create fieldset
            if (!wire('fields')->get('jk_publish_open')) {
                $opener = new Field();
                $opener->type = new FieldtypeFieldsetOpen();
                $opener->name = "jk_publish_open";
                $opener->label = $this->_('Publishing options');
                $opener->save();

                $closer = new Field();
                $closer->type = new FieldtypeFieldsetClose();
                $closer->name = "jk_publish_open" . FieldtypeFieldsetOpen::fieldsetCloseIdentifier;
                $closer->save();
            }

        }

        /**
         * Run during uninstallation of the module
         * @return void
         * @throws WireException
         * @throws WirePermissionException
         */
        public function ___uninstall(): void
        {
            // remove module fields from every template
            $this->removeFields($this->input_templates);
            // delete all fields afterwards from the database
            foreach ($this->moduleFields as $fieldname) {
                $field = wire('fields')->get($fieldname);
                $this->wire('fields')->delete($field);
            }
        }

    }
